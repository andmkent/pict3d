#lang typed/racket/base

(require racket/list
         "../../math.rkt"
         "../../gl.rkt"
         "../../utils.rkt")

(provide (all-defined-out))

(define max-shape-vertex-count 16384)

;; ===================================================================================================
;; Marshalled vertex data - contents are shader-specific

(struct vertices
  ([vertex-count : Index]
   [vertex-data : Bytes]  ; vertex data to send, already converted to bytes
   [indexes : (Vectorof Index)])
  #:transparent)
;; The length of `vertex-data` must be no less than `vertex-count` times the struct size!
;; The elements in `index-data` must be less than `vertex-count`!

;; ===================================================================================================
;; Drawing pass data

;; 1. Shapes construct Passes, which contain all the data necessaary to draw them on each drawing pass
;; (e.g. material pass, light pass, color pass); each pass is numbered and corresponds with an index
;; in the outermost vector
(struct passes ([light : (Vectorof shape-params)]
                [opaque-material : (Vectorof shape-params)]
                [opaque-color : (Vectorof shape-params)]
                [transparent-material : (Vectorof shape-params)]
                [transparent-color : (Vectorof shape-params)])
  #:transparent)

;; (`program` is lazy because programs can't be constructed until a GL context is active)
(struct shape-params ([program : (-> gl-program)]
                      [uniforms : (List-Hash String (U Symbol Uniform))]
                      [two-sided? : Boolean]
                      [mode : Integer]
                      [vertices : vertices])
  #:transparent)

;; 2. Shapes' Passes are extracted from a scene, along with the transform that should be applied by
;; the vertex shader that draws them (computed by composing the transforms in the scene tree)
(struct draw-passes ([passes : passes]
                     [affine : FlAffine3])
  #:transparent
  #:mutable)

;; 3. `draw-passes` are generated by choosing shape params by index from Passes and flattening; these
;; are then grouped by state and sent to the GPU
(struct draw-params ([shape-params : shape-params]
                     [affine : FlAffine3])
  #:transparent
  #:mutable)

(define empty-passes
  (passes #() #() #() #() #()))

(define empty-shape-params
  (shape-params (Î» () (error 'empty-shape-params)) empty #f 0 (vertices 0 #"" (vector))))

(: empty-draw-params (-> draw-params))
(define (empty-draw-params)
  (draw-params empty-shape-params identity-flaffine3))
